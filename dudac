#!/usr/bin/env python

# Copyright (C) 2012, Eduardo Silva <edsiper@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import os
import sys
import shutil
import getopt
import commands
import ConfigParser

PROTOCOL_GIT = 0
PROTOCOL_SSH = 1

def execute(header, command, status=True):
    print "[+] %-30s" % (header),
    sys.stdout.flush()

    ret = commands.getstatusoutput(command)
    if ret[0] == 0:
        if status is True:
            print "[OK]"
    else:
        if status is True:
            print "[FAILED]\n"
        print ret[1]
        exit(1)

    return ret

class DudaConfig(ConfigParser.ConfigParser):
    def __init__(self):
        ConfigParser.ConfigParser.__init__(self)

    def open(self, path):
        self.read(path)

    def get_handlers(self):
        return self.sections()

    def get_key(self, handler, key):
        try:
            val = self.get(handler, key)
            return val
        except:
            return None

class Monkey:
    recent_configure = False
    recent_build = False
    recent_clean = False

    def __init__(self, source_path):
        self.mk_path = source_path

    def configure(self):
        if self.recent_configure is True:
            return

        configure = "%s/./configure --debug --disable-plugins=auth,cheetah,mandril,logger,palm,dirlisting --enable-plugins=liana,duda" % (self.mk_path)
        execute("Monkey: prepare build", configure)

        self.recent_configure = True

    def make_build(self):
        if self.recent_build is True:
            return

        cmd = "make -C %s" % (self.mk_path)
        execute("Monkey: building", cmd)

        self.recent_build = True

    def make_clean(self):
        if self.recent_clean is True:
            return

        cmd = "make -C %s clean" % (self.mk_path)
        execute("Monkey: cleaning", cmd)

        self.recent_clean = True

    def system(self, cmd):
        return commands.getstatusoutput(cmd)

class MonkeyGIT:
    # Default repositories
    version  = 'master'
    git_repo = 'git://git.monkey-project.com/monkey'
    ssh_repo = 'ssh://git.monkey-project.com/srv/git/monkey'
    recent_update   = False
    recent_master   = False
    recent_snapshot = False

    def __init__(self):
        pass

    def set_protocol(self, protocol):
        if protocol == PROTOCOL_GIT:
            self.protocol = self.git_repo
        elif protocol == PROTOCOL_SSH:
            self.protocol = self.ssh_repo

    def setup(self, version, git_repo, ssh_repo):
        if version is not None:
            self.version = version

        if git_repo is not None:
            self.git_repo = git_repo

        if ssh_repo is not None:
            self.ssh_repo = ssh_repo

    def clone(self, to):
        cmd = "git clone " + self.protocol + " " + to
        execute("Monkey: cloning source code", cmd)

    def update(self, to):
        if self.recent_update is True:
            return

        self.master()

        cpath = os.getcwd()
        os.chdir(to)
        cmd = "git pull"
        execute("GIT: updating Monkey", cmd)
        os.chdir(cpath)

        self.recent_update = True

    def remove(self, path):
        cmd = "rm -rf- %s" % path
        print "[+] Deleting Monkey code...",
        try:
                shutil.rmtree(path)
                print "\t[OK]"
        except:
                print "\t[FAILED]"

    def run(self, cmd):
        return commands.getstatusoutput(cmd)

    def print_line(self, l):
        print l,
        sys.stdout.flush()

    def home(self):
        # Check our user temporal directory
        home = os.getenv('USERPROFILE') or os.getenv('HOME')
        dudac_home = "%s/.dudac" % (home)

        return "%s/monkey" % (dudac_home)

    # Return the current head hash
    def master(self):
        mkh = self.home()
        if os.path.exists(mkh) is False:
            pass

        if self.recent_master is True:
            return

        cmd = 'git checkout master'
        cpath = os.getcwd()
        os.chdir(self.home())
        execute("GIT: checkout master", cmd)
        os.chdir(cpath)

        self.recent_master = True

    # A snapshot takes the value of the 'version' key and set the GIT repository
    # to the specified point, a few examples:
    #
    #    version = master
    #    version = commit@dc2d07d8ac991392aaf8de8ea82cc60257a15670
    #    version = branch@my_devel_branch
    #    version = tag@v1.5
    #
    def snapshot(self):
        if self.recent_snapshot is True:
            return

        v = self.version

        try:
            if v == 'master':
                cmd = 'git checkout master'
            elif v.startswith('commit') or v.startswith('tag') or v.startswith('branch'):
                arr = v.split('@')
                cmd = 'git checkout %s' % (arr[1])
            else:
                print "Error: Invalid 'version' value"
                exit(1)
        except:
            print "Error: invalid 'version' value"
            exit(1)


        # Make sure to go back to master
        self.master()

        cpath = os.getcwd()
        os.chdir(self.home())
        execute("GIT: switch to new head", cmd)
        os.chdir(cpath)

        self.recent_snapshot = True

class Duda:
    def __init__(self):
        self.print_version()
        self.web_service = None
        self.service = None
        self.port = 2001
        self.rebuild_monkey = True
        self.mk_git = MonkeyGIT()
        self.mk_home = self.mk_git.home()
        self.monkey  = Monkey(self.mk_home)
        self.get_arguments()

    # This routine read the config.dudac configuration file which is
    # optional inside every web service source code. It specifies the
    # Monkey sources requirements and perform the right setup
    def config_requirements(self):
        ws = self.service

        config_file = os.path.abspath("%s/config.dudac" % (ws))
        if os.path.isdir(ws) == False:
            print "Error: Invalid web service directory"
            exit(1)

        # Check if the service have a configuration file
        if os.path.isfile(config_file) == False:
            return

        # Read the configuration
        config = DudaConfig()
        config.open(config_file)

        version  = None
        git_repo = None
        ssh_repo = None

        for h in config.get_handlers():
            if h == "MONKEY":
                # Get key/values
                version  = config.get_key(h, 'version')
                git_repo = config.get_key(h, 'git_repo')
                ssh_repo = config.get_key(h, 'ssh_repo')

        self.mk_git.setup(version, git_repo, ssh_repo)

    def update_framework(self, protocol):
        self.mk_git.set_protocol(protocol)

        if os.path.exists(self.mk_home):
            self.mk_git.update(self.mk_home)
        else:
            self.mk_git.clone(self.mk_home)

        # Cleanup and rebuild Monkey
        cpath = os.getcwd()
        os.chdir(self.mk_home)

        self.mk_git.snapshot()
        self.monkey.configure()
        if os.path.exists("./Makefile"):
            self.monkey.make_clean()

        self.monkey.make_build()
        os.chdir(cpath)

    def run_webservice(self):
        ws = self.service

        if self.rebuild_monkey is True:
            # Make sure Monkey sources match the snapshot
            self.mk_git.snapshot()

            # Cleanup and rebuild Monkey
            cpath = os.getcwd()
            os.chdir(self.mk_home)

            if os.path.exists("./Makefile"):
                self.monkey.make_clean()

                self.monkey.configure()
                self.monkey.make_build()
                os.chdir(cpath)

        makefile = "%s/Makefile" % (ws)
        makefile_in = "%s/Makefile.in" % (ws)
        if os.path.isdir(ws) == False or os.path.exists(makefile_in) == False:
            print "Error: Invalid web service directory"
            exit(1)

        # Monkey headers
        mk_inc = self.mk_home + "/src/include"
        mk_duda = self.mk_home + "/plugins/duda/src"
	mk_packages = self.mk_home + "/plugins/duda/"

        # Read the Makefile.in file
        f = open(makefile_in, "r")
        lines = f.readlines()
        f.close()

        raw = ""
        for line in lines:
            if line.startswith("INCDIR"):
                raw += "INCDIR = " + mk_inc + " -I" + mk_duda + " -I" + mk_packages + "\n"
            else:
                raw += line

        f = open(makefile, "w")
        f.write(raw)
        f.close()

        # Cleanup web service and rebuild
        execute("WebService: clean", "make -C " + ws + " clean")
        execute("WebService: build", "make -C " + ws)

        # Get services
        services = []
        list = os.listdir(ws)
        for entry in list:
            p = ws + "/" + entry
            if os.path.isfile(p) and entry.endswith(".duda"):
                services.append({'name': entry[:-5], 'filename': entry})

        # Setting up virtual host
        vhost = self.mk_home + "/conf/sites/default"
        f = open(vhost, "r")
        lines = f.readlines()
        f.close()

        # Setting up web services
        print "[+] %-30s" % "Monkey: configure HTTP Server",
        raw = ""
        for line in lines:
            if line.startswith('[WEB_'):
                break
            else:
                raw += line

        for s in services:
            raw += "[WEB_SERVICE]\n"
            raw += "    Name " + s['name'] + "\n"
            raw += "    Enabled on\n\n"

        f = open(vhost, "w")
        f.write(raw)
        f.close()

        # Setting up Duda plugin configuration
        duda = self.mk_home + "/conf/plugins/duda/duda.conf"
        f = open(duda, "r")
        lines = f.readlines()
        f.close()

        raw = ""
        for line in lines:
            if line.startswith("    ServicesRoot"):
                raw += "    ServicesRoot " + ws + "\n\n"
            else:
                raw += line

        f = open(duda, "w")
        f.write(raw)
        f.close()

        # Setting up Monkey
        monkey = self.mk_home + "/conf/monkey.conf"
        f = open(monkey, "r")
        lines = f.readlines()
        f.close()

        raw = ""
        for line in lines:
            if line.startswith("    Port"):
                raw += "    Port " + str(self.port) + "\n"
            else:
                raw += line

        f = open(monkey, "w")
        f.write(raw)
        f.close()

        print "[OK]"

        http = self.mk_home + "/bin/monkey"

        try:
            service = "[http://localhost:%s]" % str(self.port)
            execute("Running HTTP Server            %s\n" % service, http, False)
        except:
            print "\nDone!"

    def reset(self):
        self.mk_git.remove(self.mk_home)

    def print_version(self):
        print "Duda Client Manager - v0.2"
        print "http://monkey-project.com\n"

    def print_help(self):
        print "Usage: dudac [-g|-s] [-h] [-v] -w WEB_SERVICE_PATH\n"
        print "Options:"
        print "  -p TCP_PORT\t\tSet TCP port (default 2001)"
        print "  -w WEB_SERVICE\tSpecify web service source path"
        print "  -s\t\t\tClone/Update Monkey sources using SSH"
        print "  -g\t\t\tClone/Update Monkey sources using GIT"
        print "  -f\t\t\tDo not rebuild Monkey (fast-run)"
        print "  -r\t\t\tReset environment"
        print "  -h\t\t\tPrint this help"
        print "  -v\t\t\tPrint version"

    def get_arguments(self):
        update = None

        # Reading command line arguments
        try:
            optlist, args = getopt.getopt(sys.argv[1:], 'sgfrhvw:p:')
        except getopt.GetoptError:
            self.print_help()
            sys.exit(2)

        if len(optlist) == 0:
            self.print_help()

        # Check options
        for op, arg in optlist:
            if op == '-s':
                update = PROTOCOL_SSH
            elif op == '-g':
                update = PROTOCOL_GIT
            elif op == '-f':
                self.rebuild_monkey = False
            elif op == '-r':
                self.reset()
                exit(0)
            elif op == '-h':
                self.print_help()
                sys.exit(0)
                break
            elif op == '-p':
                if not str(arg).isdigit():
                    self.print_help()
                    exit(1)
                self.port = arg
            elif op == '-v':
                self.print_version()
                sys.exit(0)
                break
            elif op == '-w':
                self.service = arg
                self.config_requirements()

        if update is not None:
            if self.rebuild_monkey is False:
                print "Error: you cannot mix the flag -f with -g or -s"
                exit(1)

            self.update_framework(update)

        if self.service:
            self.run_webservice()

    def _temp_path(self):
        pass

if __name__ == "__main__":
    d = Duda()
